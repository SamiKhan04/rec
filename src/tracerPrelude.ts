const TRACER_LINES = [

  'from collections import defaultdict',
  'from functools import wraps',
  '',
  '',
  'class _TraceState:',
  '    __slots__ = ("next_id", "stack")',
  '',
  '    def __init__(self):',
  '        self.next_id = 0',
  '        self.stack: list[int] = []',
  '',
  '    def push(self):',
  '        node_id = self.next_id',
  '        self.next_id += 1',
  '        parent = self.stack[-1] if self.stack else None',
  '        self.stack.append(node_id)',
  '        return node_id, parent',
  '',
  '    def pop(self):',
  '        if self.stack:',
  '            self.stack.pop()',
  '',
  '    def reset(self):',
  '        self.next_id = 0',
  '        self.stack.clear()',
  '',
  '',
  '_state = _TraceState()',
  'tree: dict[int, tuple] = {}',
  '',
  '',
  'def _make_tracer(tree_dict: dict[int, tuple]):',
  '    def decorator(fn):',
  '        @wraps(fn)',
  '        def wrapper(*args, **kwargs):',
  '            node_id, parent = _state.push()',
  '            try:',
  '                result = fn(*args, **kwargs)',
  '                tree_dict[node_id] = (parent, fn.__name__, args, kwargs, result)',
  '                return result',
  '            finally:',
  '                _state.pop()',
  '',
  '        return wrapper',
  '',
  '    return decorator',
  '',
  '',
  'def trace(arg=None):',
  '    """Decorator that records calls into the global ``tree`` by default."""',
  '    if callable(arg):',
  '        return _make_tracer(tree)(arg)',
  '    target = tree if arg is None else arg',
  '    return _make_tracer(target)',
  '',
  '',
  'def reset_trace(tree_dict=None):',
  '    """Clear the recorded tree and reset tracing state."""',
  '    target = tree if tree_dict is None else tree_dict',
  '    target.clear()',
  '    _state.reset()',
  '',
  '',
  'def _build_children(tree: dict[int, tuple]):',
  '    """Build adjacency from {id: (parent, args, kwargs, ret)} mapping."""',
  '    children = defaultdict(list)',
  '    roots = []',
  '    for nid, (par, *_rest) in tree.items():',
  '        if par is None:',
  '            roots.append(nid)',
  '        children[par].append(nid)',
  '    return children, roots',
  '',
  '',
  'def dfs(tree: dict[int, tuple], start: int | None = None, visit=lambda nid, node, depth: None):',
  '    """Depth-first traversal over the call tree."""',
  '    children, roots = _build_children(tree)',
  '',
  '    def _walk(nid: int, depth: int):',
  '        node = tree[nid]',
  '        visit(nid, node, depth)',
  '        for c in children.get(nid, []):',
  '            _walk(c, depth + 1)',
  '',
  '    if start is None:',
  '        for r in roots:',
  '            _walk(r, 0)',
  '    else:',
  '        _walk(start, 0)',
  '',
  '',
  'def print_ascii_tree(tree: dict[int, tuple], label_fn=None):',
  '    """Print an ASCII tree using box-drawing characters."""',
  '    children, roots = _build_children(tree)',
  '',
  '    def default_label(nid, node):',
  '        _par, fn_name, args, kwargs, ret = node',
  '        args_label = ", ".join(map(repr, args))',
  '        if kwargs:',
  '            return f"{fn_name}#{nid}({args_label}, **{kwargs}) -> {ret!r}"',
  '        return f"{fn_name}#{nid}({args_label}) -> {ret!r}"',
  '',
  '    if label_fn is None:',
  '        label_fn = default_label',
  '',
  '    def _recurse(nid: int, prefix: str, is_last: bool):',
  '        node = tree[nid]',
  '        connector = "└── " if is_last else "├── "',
  '        print(prefix + connector + label_fn(nid, node))',
  '        kids = children.get(nid, [])',
  '        child_prefix = prefix + ("    " if is_last else "│   ")',
  '        for i, c in enumerate(kids):',
  '            _recurse(c, child_prefix, i == len(kids) - 1)',
  '',
  '    for r_i, r in enumerate(roots):',
  '        print(label_fn(r, tree[r]))',
  '        kids = children.get(r, [])',
  '        for i, c in enumerate(kids):',
  '            _recurse(c, "", i == len(kids) - 1)',
  '        if r_i != len(roots) - 1:',
  '            print()',
  '',
  '',
  'def print_indented(tree: dict[int, tuple]):',
  '    """Simpler, space-indented view of the call tree."""',
  '    children, roots = _build_children(tree)',
  '',
  '    def _walk(nid: int, depth: int):',
  '        _par, fn_name, args, kwargs, ret = tree[nid]',
  '        args_s = ", ".join(map(repr, args))',
  '        kw_s = (", **" + repr(kwargs)) if kwargs else ""',
  '        print("  " * depth + f"{fn_name}#{nid}({args_s}{kw_s}) -> {ret!r}")',
  '        for c in children.get(nid, []):',
  '            _walk(c, depth + 1)',
  '',
  '    for r in roots:',
  '        _walk(r, 0)'
] as const;

export const TRACER_PY = TRACER_LINES.join("\n");

